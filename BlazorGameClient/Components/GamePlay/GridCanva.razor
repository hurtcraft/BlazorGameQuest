@using BlazorGameClient.Pages
@using BlazorGameQuestClassLib


<canvas id="myCanvas" @onmousemove="OnMouseMove" @onmousedown="OnMouseDown" @onmouseup="OnMouseUp"
    @onclick="OnMouseClick" @oncontextmenu="PreventContextMenu" width=@CANVA_WIDTH height=@CANVA_HEIGHT
    style="border:1px solid black;"></canvas>


@code {
    @inject IJSRuntime JS
    [Parameter] public bool IsEditing { get; set; }
    [Parameter] public required GameGrid gameGrid { get; set; }=new GameGrid();
    public readonly int NB_SPRITE_LARGEUR = GameGrid.NB_SPRITE_LARGEUR; //20
    public readonly int NB_SPRITE_LONGUEUR = GameGrid.NB_SPRITE_LONGUEUR; //30
    public readonly int SPRITE_SIZE = GameGrid.SPRITE_SIZE;
    public readonly int CANVA_X = 0;
    public readonly int CANVA_Y = 0;
    public readonly int CANVA_WIDTH;
    public readonly int CANVA_HEIGHT;

    private int mouseX;
    private int mouseY;
    private bool isLeftClick = false;
    private bool isRightClick = false;

    public GridCanva()
    {
        CANVA_WIDTH = NB_SPRITE_LONGUEUR * SPRITE_SIZE;
        CANVA_HEIGHT = NB_SPRITE_LARGEUR * SPRITE_SIZE;
        //PrintGrid();

    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await DrawGrid();
        }
    }

    public async Task DrawGrid()
    {
        await JS.InvokeVoidAsync("drawGrid", NB_SPRITE_LONGUEUR, NB_SPRITE_LARGEUR, SPRITE_SIZE);
    }
    public async Task DrawFrame(string imagePath, int x, int y)
    {
        await JS.InvokeVoidAsync("drawTile", imagePath, x, y, SPRITE_SIZE);
    }

    private async Task DrawSelectedTile(int x, int y)
    {
        if (!IsEditing) return;
        if (GameAsset.currentMapTile.HasValue)
        {

            int indexTile = GameAsset.currentMapTile.Value;
            string tilePath = GameAsset.ListMapTile[indexTile];
            if (gameGrid.grid[y][x][^1] != indexTile)
            {// si dernier elt == elt courant ne pas ajouter pour eco mémoire
                gameGrid.grid[y][x].Add(indexTile);
            }



            await JS.InvokeVoidAsync("drawTile", tilePath, x, y, SPRITE_SIZE);
        }
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        if (!IsEditing) return;
        isLeftClick = e.Button == 0;
        isRightClick = e.Button == 2;

        if (isRightClick)
        {
            _ = EraseTile(mouseX, mouseY);
            isLeftClick = false;
        }
        if (isLeftClick)
        {
            _ = DrawSelectedTile(mouseX, mouseY);
        }
    ;

    }
    public async Task DrawFromGameGrid(GameGrid _grid)
    {
        Console.WriteLine("loooool "+gameGrid.grid);


        if (_grid == null) return;
        //gameGrid = _grid;
        gameGrid.grid = _grid.grid;
        await DrawGrid();

        // On efface le canvas avant de redraw
        for (int i = 0; i < gameGrid.grid.Count(); i++)
        {
            for (int j = 0; j < gameGrid.grid[0].Count(); j++)
            {
                for (int k = 0; k < gameGrid.grid[i][j].Count(); k++)
                {

                    int tileIndex = gameGrid.grid[i][j][k];
                    //Console.WriteLine(i+" "+j+" "+ string.Join(",",gameGrid.grid[i][j]));
                    if (tileIndex != -1)
                    {

                        string tilePath = GameAsset.ListMapTile[tileIndex];
                        await JS.InvokeVoidAsync("drawTile", tilePath, j, i, SPRITE_SIZE);
                    }



                }
            }
        }

    }
    private void OnMouseUp(MouseEventArgs e)
    {
        if (!IsEditing) return;

        isLeftClick = false;
        isRightClick = false;


    }
    private void OnMouseMove(MouseEventArgs e)
    {
        if (!IsEditing) return;
        mouseX = (int)e.OffsetX / SPRITE_SIZE;
        mouseY = (int)e.OffsetY / SPRITE_SIZE;
        if (isLeftClick)
        {
            _ = DrawSelectedTile(mouseX, mouseY);
        }
        if (isRightClick)
        {
            _ = EraseTile(mouseX, mouseY);
        }


    }
    public async Task ClearTile(int x,int y){
        await JS.InvokeVoidAsync("eraseTile", x, y, SPRITE_SIZE);

    }
    private async Task EraseTile(int x, int y)
    {
        if (!IsEditing)
        {
            return;
        }
        await JS.InvokeVoidAsync("eraseTile", x, y, SPRITE_SIZE);
        gameGrid.grid[y][x] = new List<int> { -1 };
    }
    private async Task OnMouseClick(MouseEventArgs e)
    {
        if (!IsEditing) return;

        if (e.Button == 0)
        {
            await DrawSelectedTile(mouseX, mouseY);
        }
        if (e.Button == 2)
        {
            await EraseTile(mouseX, mouseY);
        }
    }
    private void PrintGrid()
    {
        // Sérialise directement la grille en JSON
        Console.WriteLine(gameGrid.grid[0][0]);
    }
    private void PreventContextMenu(MouseEventArgs e)
    {

    }
}