@using BlazorGameClient.Pages
@using BlazorGameQuestClassLib


<canvas id="myCanvas" @onmousemove="OnMouseMove" @onmousedown="OnMouseDown" @onmouseup="OnMouseUp"
    @onclick="OnMouseClick" @oncontextmenu="PreventContextMenu" width=@CANVA_WIDTH height=@CANVA_HEIGHT
    style="border:1px solid black;"></canvas>


@code {
    @inject IJSRuntime JS
    [Parameter] public bool IsEditing { get; set; }
    [Parameter] public required GameGrid gameGrid{get;set;}
    public readonly int NB_SPRITE_LARGEUR = GameGrid.NB_SPRITE_LARGEUR; //20
    public readonly int NB_SPRITE_LONGUEUR = GameGrid.NB_SPRITE_LONGUEUR; //30
    public readonly int SPRITE_SIZE = GameGrid.SPRITE_SIZE;
    public readonly int CANVA_X = 0;
    public readonly int CANVA_Y = 0;
    public readonly int CANVA_WIDTH;
    public readonly int CANVA_HEIGHT;

    private int mouseX;
    private int mouseY;
    private bool isLeftClick = false;
    private bool isRightClick = false;

    public GridCanva()
    {
        CANVA_WIDTH = NB_SPRITE_LONGUEUR * SPRITE_SIZE;
        CANVA_HEIGHT = NB_SPRITE_LARGEUR * SPRITE_SIZE;
        //PrintGrid();

    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await DrawGrid();
        }
    }

    private async Task DrawGrid()
    {
        await JS.InvokeVoidAsync("drawGrid", NB_SPRITE_LONGUEUR, NB_SPRITE_LARGEUR, SPRITE_SIZE);
    }


    private async Task DrawSelectedTile(int x, int y)
    {
        if (!IsEditing) return;
        if (GameAsset.currentMapTile.HasValue)
        {
            Console.WriteLine("appel drw tata");

            int indexTile = GameAsset.currentMapTile.Value;
            string tilePath = GameAsset.ListMapTile[indexTile];
            if(gameGrid.grid[y][x][^1]!=indexTile){// si dernier elt == elt courant ne pas ajouter pour eco mémoire
                gameGrid.grid[y][x].Add(indexTile) ;
            }
            


            await JS.InvokeVoidAsync("drawTile", tilePath, x, y, SPRITE_SIZE);
        }
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        if (!IsEditing) return;
        isLeftClick = e.Button == 0;
        isRightClick = e.Button == 2;

        if (isRightClick)
        {
            _ = EraseTile(mouseX, mouseY);
            isLeftClick = false;
        }
        if (isLeftClick)
        {
            _ = DrawSelectedTile(mouseX, mouseY);
        }
    ;

    }

    private void OnMouseUp(MouseEventArgs e)
    {
        if (!IsEditing) return;

        isLeftClick = false;
        isRightClick = false;


    }
    private void OnMouseMove(MouseEventArgs e)
    {
        if (!IsEditing) return;
        mouseX = (int)e.OffsetX / SPRITE_SIZE;
        mouseY = (int)e.OffsetY / SPRITE_SIZE;
        if (isLeftClick)
        {
            _ = DrawSelectedTile(mouseX, mouseY);
        }
        if (isRightClick)
        {
            _ = EraseTile(mouseX, mouseY);
        }


    }
    private async Task EraseTile(int x, int y)
    {
        if (!IsEditing)
        {
            return;
        }
        await JS.InvokeVoidAsync("eraseTile", x, y, SPRITE_SIZE);
        gameGrid.grid[y][x]=new List<int>{-1};
    }
    private async Task OnMouseClick(MouseEventArgs e)
    {
        if (!IsEditing) return;

        if (e.Button == 0)
        {
            await DrawSelectedTile(mouseX, mouseY);
        }
        if (e.Button == 2)
        {
            await EraseTile(mouseX, mouseY);
        }
    }
    private void PrintGrid()
    {
        // Sérialise directement la grille en JSON
        Console.WriteLine(gameGrid.grid[0][0]);
    }
    private void PreventContextMenu(MouseEventArgs e)
    {

    }
}